import os
import Options, Utils
from TaskGen import feature, before, task_gen

def options(opt):
    opt.add_option('--disable-pcre', action='store_false', dest='enable_pcre',
                   help='turn off PCRE')
    opt.add_option('--enable-pcre', action='store_true',
                   default=True, help='turn on PCRE (default)')
    opt.add_option('--with-pcre-home', action='store',
                   help='Specify the PCRE Home - where PCRE is installed to')
    opt.add_option('--build-pcre', action='store_true', dest='build_pcre',
                   default=True, help='force building PCRE from scratch')
    opt.add_option('--nobuild-pcre', action='store_false', dest='build_pcre',
                   help='force building PCRE from scratch')

def configure(conf):
    #-- PCRE -------------------------------------------------------------------
    enablePCRE = Options.options.enable_pcre
    
    if enablePCRE:
        pcreHome = Options.options.with_pcre_home
        makePCRE = False
        if Options.options.build_pcre:
            makePCRE = True
        elif pcreHome:
            conf.msg('Setting pcre home', pcreHome)
            conf.env.append_value('LIBPATH_PCRE', os.path.join(pcreHome, 'lib'))
            conf.env.append_value('CPPPATH_PCRE', os.path.join(pcreHome, 'include'))
        else:
            if not conf.check_cxx(lib='pcre', mandatory=False,
                                  uselib_store='PCRE'):
                #default to building locally
                makePCRE = True
        if makePCRE:
            conf.env['MAKE_PCRE'] = makePCRE
            conf.msg('Building local lib', 'pcre')
        else:
            conf.env['LIB_PCRE'] = ['pcre']

def build(bld):
    variant = bld.env['VARIANT']
    env = bld.env_of_name(variant)
    env.set_variant(variant)

    driversNode = bld.path
    
    if 'MAKE_PCRE' in env:
        fname = 'pcre-5.0'
        bld.set_group(0)
        ut = bld.new_task_gen(path=bld.path, env=env.copy(),
                              fname='%s.tar' % fname)
        bld.set_group(1)
        ut.features = ['untar']
        #bld.add_group()

        driverNode = driversNode.make_node(fname)
        
        #we need to do a few substitution transformations
        #these taken from the configure.in in the package
        pcreDict = dict(PCRE_MAJOR=5, PCRE_MINOR=0, PCRE_DATE='13-Sep-2004',
                        MATCH_LIMIT=10000000, POSIX_MALLOC_THRESHOLD=10,
                        HAVE_STRERROR=env['HAVE_STRERROR'],
                        HAVE_MEMMOVE=env['HAVE_MEMMOVE'],
                        HAVE_BCOPY=env['HAVE_BCOPY'],
                        EBCDIC=0, NEWLINE="'\\n'", LINK_SIZE=2,
                        EXPORT=None)
        
        configH = bld.new_task_gen(name='config_h', output='config.h',
                                   path=driverNode, env=env.copy(),
                                   defs=pcreDict)
        configH.features = ['makeHeader']
        
        pcreH = bld.new_task_gen(name='pcre_in', input='pcre.in', output='pcre.h', env=env.copy(),
                                 dict=pcreDict, path=driverNode)
        pcreH.features = ['m4subst']
        #bld.add_group()
        
        #make the dftables executable
        appName = Options.platform.startswith('win32') and 'dftables.exe' or 'dftables'
        dfTablesNode = driverNode.find_or_declare(appName)
        dfTables = bld.new_task_gen(features='c cprogram', source='dftables.c',
                                    includes=['.'],
                                    target='dftables',
                                    path=driverNode,
                                    install_path=None,
                                    env=env.copy(), name='dftables')
        #bld.add_group()
        # waf complains if dfTablesNode doesn't have a signature, just use the tar file's sig.
        if not os.path.exists(dfTablesNode.abspath()):
            dfTablesNode.sig = Utils.h_file(os.path.join(bld.path.abspath(), '%s.tar' % fname))
        charTables = bld.new_task_gen(features='add_targets', source = dfTablesNode, path=driverNode,
                                      rule='${SRC} ${TGT}', target='chartables.c',
                                      install_path=None, deps=appName,
                                      env=env.copy(), targets_to_add='dftables')
        #bld.add_group()
        
        
        pcreposix = bld.new_task_gen(features='c c%s' % env['LIB_TYPE'] or 'stlib',
                         includes=['.'], env=env.copy(),
                         target='pcreposix', source='pcreposix.c',
                         path=driverNode, export_includes='.')
        
        pcre = bld.new_task_gen(features='c c%s add_targets' % env['LIB_TYPE'] or 'stlib',
                         includes=['.'],
                         export_includes='.',
                         target='pcre',
                         source='maketables.c get.c study.c pcre.c',
                         path=driverNode,
                         env=env.copy(),
                         name='PCRE',
                         use='chartables.c',
                         targets_to_add=['pcre_install', 'config_h', 'pcre_in'],
                         install_path='${PREFIX}/lib')
        #bld.add_group()
        
        bld(features='install_tgt', install_path='${PREFIX}/include',
                      dir=driverNode, files=['pcre.h', 'pcreposix.h'], name='pcre_install')

def distclean(context):
    #remove the untarred directories
    import shutil
    
    dirs = map(lambda d: os.path.join(context.path.abspath(), d),
               ['pcre-5.0'])
    for d in dirs:
        try:
            if os.path.exists(d):
                shutil.rmtree(d, ignore_errors=True)
        except:{}
    
