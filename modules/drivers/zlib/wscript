import os
from waflib import Options
from waflib.TaskGen import feature, before, task_gen
from build import untarFile

ZLIB_VERSION = 'zlib-1.2.7'

def options(opt):
    opt.add_option('--with-zip-home', action='store', dest='zip_home',
                   help='Specify the ZIP Home - where the ZIP library is installed')
    opt.add_option('--disable-zip', action='store_false', dest='enable_zip',
                   help='will not build the zip (zlib) library')
    opt.add_option('--enable-zip', action='store_true',
                   default=True, help='will build the zip (libz) library if not found on the system (default)')
    opt.add_option('--build-zip', action='store_true', dest="build_zip",
                   help='force building zip (zlib) library from scratch',
                   default=os.path.exists(os.path.join(opt.path.abspath(), ZLIB_VERSION + '.tar')))
    opt.add_option('--nobuild-zip', action='store_false', dest="build_zip",
                   help='force not building zip (zlib) library from scratch')

def configure(conf):
    #-- ZIP --------------------------------------------------------------------
    if Options.options.enable_zip:

        zipHome = Options.options.zip_home
        if zipHome:
            conf.check(lib='z', uselib_store='ZIP',
                       header_name='zlib.h', function_name='inflate',
                       libpath=os.path.join(zipHome, 'lib'),
                       includes=os.path.join(zipHome, 'include'),
                       msg='Checking for library zlib', okmsg=zipHome,
                       mandatory=False)

        elif Options.options.build_zip:
            # Build is off by default when tarfile not found, fail if forced on
            if not os.path.exists(os.path.join(conf.path.abspath(), ZLIB_VERSION + '.tar')):
                conf.fatal('Missing zlib tarfile')

            conf.env['MAKE_ZIP'] = True
            conf.msg('Building local lib', 'zip (zlib)')
            
            untarFile(path=conf.path, fname=ZLIB_VERSION + '.tar')

        else:
            conf.check(lib='z', uselib_store='ZIP',
                       header_name='zlib.h', function_name='inflate',
                       msg='Checking for library zlib',
                       mandatory=False)

def build(bld):
    variant = bld.env['VARIANT']
    env = bld.all_envs[variant]

    driversNode = bld.path
    
    if 'MAKE_ZIP' in env:
        fname = ZLIB_VERSION
        
        driverNode = driversNode.make_node(fname)
        
        if env['CC_NAME'] == 'msvc' and env['LIB_TYPE'] == 'shlib':
            defs = ['ZLIB_DLL']
        else:
            defs = []
        
        zlib = bld(features='c c%s' % env['LIB_TYPE'] or 'stlib',
                         includes=['.'],
                         export_includes='.',
                         target='z',
                         source='adler32.c crc32.c deflate.c infback.c inffast.c inflate.c inftrees.c trees.c zutil.c ' \
                                'compress.c uncompr.c gzclose.c gzlib.c gzread.c gzwrite.c',
                         path=driverNode,
                         defines=env['DEFINES'] + defs,
                         env=env.derive(),
                         name='ZIP')
        if env['install_libs']:
            zlib.install_path = env['install_libdir']
        
        if env['install_headers']:
            bld(features='install_tgt', install_path=env['install_includedir'],
                dir=driverNode, pattern='zlib.h')

def distclean(context):
    #remove the untarred directories
    import shutil
    
    dirs = map(lambda d: os.path.join(context.path.abspath(), d),
               [ZLIB_VERSION])
    for d in dirs:
        try:
            if os.path.exists(d):
                shutil.rmtree(d, ignore_errors=True)
        except:{}
    
