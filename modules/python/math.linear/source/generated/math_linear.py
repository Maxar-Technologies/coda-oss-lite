# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

import _math_linear
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _math_linear.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _math_linear.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, size_t n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _math_linear.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, size_t n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _math_linear.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, PySwigIterator x) -> ptrdiff_t"""
        return _math_linear.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, PySwigIterator x) -> bool"""
        return _math_linear.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _math_linear.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _math_linear.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _math_linear.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, ptrdiff_t n) -> PySwigIterator"""
        return _math_linear.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, PySwigIterator x) -> bool"""
        return _math_linear.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, PySwigIterator x) -> bool"""
        return _math_linear.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, ptrdiff_t n) -> PySwigIterator"""
        return _math_linear.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, ptrdiff_t n) -> PySwigIterator"""
        return _math_linear.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, ptrdiff_t n) -> PySwigIterator"""
        return _math_linear.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, ptrdiff_t n) -> PySwigIterator
        __sub__(self, PySwigIterator x) -> ptrdiff_t
        """
        return _math_linear.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _math_linear.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class std_vector_double(_object):
    """Proxy of C++ std_vector_double class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, std_vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, std_vector_double, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PyObject PYTHON_SELF) -> PySwigIterator"""
        return _math_linear.std_vector_double_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _math_linear.std_vector_double___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> size_type"""
        return _math_linear.std_vector_double___len__(*args)

    def pop(*args):
        """pop(self) -> value_type"""
        return _math_linear.std_vector_double_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, difference_type i, difference_type j) -> std_vector_double"""
        return _math_linear.std_vector_double___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, difference_type i, difference_type j, std_vector_double v)"""
        return _math_linear.std_vector_double___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _math_linear.std_vector_double___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, difference_type i)"""
        return _math_linear.std_vector_double___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, difference_type i) -> value_type"""
        return _math_linear.std_vector_double___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, difference_type i, value_type x)"""
        return _math_linear.std_vector_double___setitem__(*args)

    def append(*args):
        """append(self, value_type x)"""
        return _math_linear.std_vector_double_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _math_linear.std_vector_double_empty(*args)

    def size(*args):
        """size(self) -> size_type"""
        return _math_linear.std_vector_double_size(*args)

    def clear(*args):
        """clear(self)"""
        return _math_linear.std_vector_double_clear(*args)

    def swap(*args):
        """swap(self, std_vector_double v)"""
        return _math_linear.std_vector_double_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> allocator_type"""
        return _math_linear.std_vector_double_get_allocator(*args)

    def begin(*args):
        """begin(self) -> const_iterator"""
        return _math_linear.std_vector_double_begin(*args)

    def end(*args):
        """end(self) -> const_iterator"""
        return _math_linear.std_vector_double_end(*args)

    def rbegin(*args):
        """rbegin(self) -> const_reverse_iterator"""
        return _math_linear.std_vector_double_rbegin(*args)

    def rend(*args):
        """rend(self) -> const_reverse_iterator"""
        return _math_linear.std_vector_double_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _math_linear.std_vector_double_pop_back(*args)

    def erase(*args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _math_linear.std_vector_double_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> std_vector_double
        __init__(self, std_vector_double ?) -> std_vector_double
        __init__(self, size_type size) -> std_vector_double
        __init__(self, size_type size, value_type value) -> std_vector_double
        """
        this = _math_linear.new_std_vector_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, value_type x)"""
        return _math_linear.std_vector_double_push_back(*args)

    def front(*args):
        """front(self) -> value_type"""
        return _math_linear.std_vector_double_front(*args)

    def back(*args):
        """back(self) -> value_type"""
        return _math_linear.std_vector_double_back(*args)

    def assign(*args):
        """assign(self, size_type n, value_type x)"""
        return _math_linear.std_vector_double_assign(*args)

    def resize(*args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _math_linear.std_vector_double_resize(*args)

    def insert(*args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _math_linear.std_vector_double_insert(*args)

    def reserve(*args):
        """reserve(self, size_type n)"""
        return _math_linear.std_vector_double_reserve(*args)

    def capacity(*args):
        """capacity(self) -> size_type"""
        return _math_linear.std_vector_double_capacity(*args)

    __swig_destroy__ = _math_linear.delete_std_vector_double
    __del__ = lambda self : None;
std_vector_double_swigregister = _math_linear.std_vector_double_swigregister
std_vector_double_swigregister(std_vector_double)

class Matrix3x1(_object):
    """Proxy of C++ Matrix3x1 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix3x1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix3x1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mRaw"] = _math_linear.Matrix3x1_mRaw_set
    __swig_getmethods__["mRaw"] = _math_linear.Matrix3x1_mRaw_get
    if _newclass:mRaw = _swig_property(_math_linear.Matrix3x1_mRaw_get, _math_linear.Matrix3x1_mRaw_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Matrix3x1
        __init__(self, double cv) -> Matrix3x1
        __init__(self, double raw) -> Matrix3x1
        __init__(self, std_vector_double raw) -> Matrix3x1
        __init__(self, Matrix3x1 mx) -> Matrix3x1
        """
        this = _math_linear.new_Matrix3x1(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _math_linear.delete_Matrix3x1
    __del__ = lambda self : None;
    def __call__(*args):
        """
        __call__(self, size_t i, size_t j) -> double
        __call__(self, size_t i, size_t j) -> double
        """
        return _math_linear.Matrix3x1___call__(*args)

    def row(*args):
        """
        row(self, size_t i) -> double
        row(self, size_t i) -> double
        row(self, size_t i, double vec)
        row(self, size_t i, std_vector_double vec)
        """
        return _math_linear.Matrix3x1_row(*args)

    def col(*args):
        """
        col(self, size_t j) -> std_vector_double
        col(self, size_t j, double vec)
        col(self, size_t j, std_vector_double vec)
        col(self, size_t colIdx, Matrix3x1 vec)
        """
        return _math_linear.Matrix3x1_col(*args)

    def rows(*args):
        """rows(self) -> size_t"""
        return _math_linear.Matrix3x1_rows(*args)

    def cols(*args):
        """cols(self) -> size_t"""
        return _math_linear.Matrix3x1_cols(*args)

    def size(*args):
        """size(self) -> size_t"""
        return _math_linear.Matrix3x1_size(*args)

    def scale(*args):
        """scale(self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1_scale(*args)

    def multiply(*args):
        """multiply(self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1_multiply(*args)

    def scaleDiagonal(*args):
        """scaleDiagonal(self, math::linear::MatrixMxN<(1,1,double)> mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_scaleDiagonal(*args)

    def multiplyDiagonal(*args):
        """multiplyDiagonal(self, math::linear::MatrixMxN<(1,1,double)> mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_multiplyDiagonal(*args)

    def __iadd__(*args):
        """__iadd__(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1___isub__(*args)

    def add(*args):
        """add(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1_add(*args)

    def subtract(*args):
        """subtract(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1_subtract(*args)

    def transpose(*args):
        """transpose(self) -> math::linear::MatrixMxN<(1,3,double)>"""
        return _math_linear.Matrix3x1_transpose(*args)

    def decomposeLU(*args):
        """decomposeLU(self, std::vector<(size_t,std::allocator<(size_t)>)> pivotsM) -> Like_T"""
        return _math_linear.Matrix3x1_decomposeLU(*args)

    def permute(*args):
        """
        permute(self, std::vector<(size_t,std::allocator<(size_t)>)> pivotsM, 
            size_t n=1) -> Like_T
        permute(self, std::vector<(size_t,std::allocator<(size_t)>)> pivotsM) -> Like_T
        """
        return _math_linear.Matrix3x1_permute(*args)

    def norm(*args):
        """norm(self) -> double"""
        return _math_linear.Matrix3x1_norm(*args)

    def normalize(*args):
        """normalize(self) -> Matrix3x1"""
        return _math_linear.Matrix3x1_normalize(*args)

    def unit(*args):
        """unit(self) -> Like_T"""
        return _math_linear.Matrix3x1_unit(*args)

    def __add__(*args):
        """__add__(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1___add__(*args)

    def __sub__(*args):
        """__sub__(self, Like_T mx) -> Like_T"""
        return _math_linear.Matrix3x1___sub__(*args)

    def __mul__(*args):
        """__mul__(self, double scalar) -> Like_T"""
        return _math_linear.Matrix3x1___mul__(*args)

    def __div__(*args):
        """__div__(self, double scalar) -> Like_T"""
        return _math_linear.Matrix3x1___div__(*args)

Matrix3x1_swigregister = _math_linear.Matrix3x1_swigregister
Matrix3x1_swigregister(Matrix3x1)

class Vector3(_object):
    """Proxy of C++ Vector3 class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Vector3
        __init__(self, double sv) -> Vector3
        __init__(self, double raw) -> Vector3
        __init__(self, Vector3 v) -> Vector3
        __init__(self, Matrix3x1 mx) -> Vector3
        __init__(self, std_vector_double raw) -> Vector3
        """
        this = _math_linear.new_Vector3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _math_linear.delete_Vector3
    __del__ = lambda self : None;
    def matrix(*args):
        """
        matrix(self) -> Matrix3x1
        matrix(self) -> Matrix3x1
        """
        return _math_linear.Vector3_matrix(*args)

    def size(*args):
        """size(self) -> size_t"""
        return _math_linear.Vector3_size(*args)

    def dot(*args):
        """dot(self, Vector3 vec) -> double"""
        return _math_linear.Vector3_dot(*args)

    def normDot(*args):
        """normDot(self, Vector3 vec) -> double"""
        return _math_linear.Vector3_normDot(*args)

    def norm(*args):
        """norm(self) -> double"""
        return _math_linear.Vector3_norm(*args)

    def normalize(*args):
        """normalize(self)"""
        return _math_linear.Vector3_normalize(*args)

    def unit(*args):
        """unit(self) -> Like_T"""
        return _math_linear.Vector3_unit(*args)

    def scale(*args):
        """scale(self, double scalar)"""
        return _math_linear.Vector3_scale(*args)

    def __iadd__(*args):
        """__iadd__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___isub__(*args)

    def add(*args):
        """add(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3_add(*args)

    def subtract(*args):
        """subtract(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3_subtract(*args)

    def __add__(*args):
        """__add__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___add__(*args)

    def __sub__(*args):
        """__sub__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___sub__(*args)

    def __imul__(*args):
        """
        __imul__(self, Like_T v) -> Like_T
        __imul__(self, double sv) -> Like_T
        """
        return _math_linear.Vector3___imul__(*args)

    def __idiv__(*args):
        """__idiv__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___idiv__(*args)

    def __mul__(*args):
        """
        __mul__(self, double sv) -> Like_T
        __mul__(self, Like_T v) -> Like_T
        """
        return _math_linear.Vector3___mul__(*args)

    def __div__(*args):
        """__div__(self, Like_T v) -> Like_T"""
        return _math_linear.Vector3___div__(*args)

    def __getitem__(*args):
        """__getitem__(self, long i) -> double"""
        return _math_linear.Vector3___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, long i, double val)"""
        return _math_linear.Vector3___setitem__(*args)

    def __str__(*args):
        """__str__(self) -> char"""
        return _math_linear.Vector3___str__(*args)

    def vals(*args):
        """vals(self) -> std_vector_double"""
        return _math_linear.Vector3_vals(*args)

Vector3_swigregister = _math_linear.Vector3_swigregister
Vector3_swigregister(Vector3)


def cross(*args):
  """cross(Vector3 u, Vector3 v) -> Vector3"""
  return _math_linear.cross(*args)


