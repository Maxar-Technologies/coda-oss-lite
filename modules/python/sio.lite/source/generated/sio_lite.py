# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sio_lite', [dirname(__file__)])
        except ImportError:
            import _sio_lite
            return _sio_lite
        if fp is not None:
            try:
                _mod = imp.load_module('_sio_lite', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _sio_lite = swig_import_helper()
    del swig_import_helper
else:
    import _sio_lite
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



_sio_lite.NativeLayer_func___swigconstant(_sio_lite)
NativeLayer_func__ = _sio_lite.NativeLayer_func__

_sio_lite.SYS_FUNC_swigconstant(_sio_lite)
SYS_FUNC = _sio_lite.SYS_FUNC

def isBigEndianSystem():
    """isBigEndianSystem() -> bool"""
    return _sio_lite.isBigEndianSystem()

def byteSwap(buffer, elemSize, numElems):
    """byteSwap(void * buffer, unsigned short elemSize, size_t numElems)"""
    return _sio_lite.byteSwap(buffer, elemSize, numElems)

def alignedAlloc(*args):
    """
    alignedAlloc(size_t size, size_t alignment)
    alignedAlloc(size_t size) -> void *
    """
    return _sio_lite.alignedAlloc(*args)

def alignedFree(p):
    """alignedFree(void * p)"""
    return _sio_lite.alignedFree(p)
class InputStream(_object):
    """Proxy of C++ io::InputStream class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    IS_EOF = _sio_lite.InputStream_IS_EOF
    IS_END = _sio_lite.InputStream_IS_END
    DEFAULT_CHUNK_SIZE = _sio_lite.InputStream_DEFAULT_CHUNK_SIZE
    __swig_destroy__ = _sio_lite.delete_InputStream
    __del__ = lambda self: None

    def available(self):
        """available(InputStream self) -> sys::Off_T"""
        return _sio_lite.InputStream_available(self)


    def read(self, b, len):
        """read(InputStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.InputStream_read(self, b, len)


    def readln(self, cStr, strLenPlusNullByte):
        """readln(InputStream self, sys::byte * cStr, sys::Size_T const strLenPlusNullByte) -> sys::SSize_T"""
        return _sio_lite.InputStream_readln(self, cStr, strLenPlusNullByte)


    def streamTo(self, *args):
        """
        streamTo(InputStream self, OutputStream & soi, sys::SSize_T numBytes) -> sys::SSize_T
        streamTo(InputStream self, OutputStream & soi) -> sys::SSize_T
        """
        return _sio_lite.InputStream_streamTo(self, *args)

InputStream_swigregister = _sio_lite.InputStream_swigregister
InputStream_swigregister(InputStream)
cvar = _sio_lite.cvar
SSE_INSTRUCTION_ALIGNMENT = cvar.SSE_INSTRUCTION_ALIGNMENT

class OutputStream(_object):
    """Proxy of C++ io::OutputStream class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OutputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_OutputStream
    __del__ = lambda self: None

    def writeln(self, str):
        """writeln(OutputStream self, std::string const & str)"""
        return _sio_lite.OutputStream_writeln(self, str)


    def write(self, *args):
        """
        write(OutputStream self, sys::byte b)
        write(OutputStream self, std::string const & str)
        write(OutputStream self, sys::byte const * b, sys::Size_T len)
        """
        return _sio_lite.OutputStream_write(self, *args)


    def flush(self):
        """flush(OutputStream self)"""
        return _sio_lite.OutputStream_flush(self)


    def close(self):
        """close(OutputStream self)"""
        return _sio_lite.OutputStream_close(self)

OutputStream_swigregister = _sio_lite.OutputStream_swigregister
OutputStream_swigregister(OutputStream)

class BidirectionalStream(InputStream, OutputStream):
    """Proxy of C++ io::BidirectionalStream class"""
    __swig_setmethods__ = {}
    for _s in [InputStream, OutputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BidirectionalStream, name, value)
    __swig_getmethods__ = {}
    for _s in [InputStream, OutputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BidirectionalStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_BidirectionalStream
    __del__ = lambda self: None
BidirectionalStream_swigregister = _sio_lite.BidirectionalStream_swigregister
BidirectionalStream_swigregister(BidirectionalStream)

class Seekable(_object):
    """Proxy of C++ io::Seekable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Seekable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Seekable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_Seekable
    __del__ = lambda self: None
    CURRENT = _sio_lite.Seekable_CURRENT
    START = _sio_lite.Seekable_START
    END = _sio_lite.Seekable_END

    def seek(self, offset, whence):
        """seek(Seekable self, sys::Off_T offset, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.Seekable_seek(self, offset, whence)


    def tell(self):
        """tell(Seekable self) -> sys::Off_T"""
        return _sio_lite.Seekable_tell(self)

Seekable_swigregister = _sio_lite.Seekable_swigregister
Seekable_swigregister(Seekable)

class SeekableInputStream(InputStream, Seekable):
    """Proxy of C++ io::SeekableInputStream class"""
    __swig_setmethods__ = {}
    for _s in [InputStream, Seekable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SeekableInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [InputStream, Seekable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SeekableInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_SeekableInputStream
    __del__ = lambda self: None

    def read(self, b, len):
        """read(SeekableInputStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.SeekableInputStream_read(self, b, len)


    def streamTo(self, *args):
        """
        streamTo(SeekableInputStream self, OutputStream & soi, sys::SSize_T numBytes) -> sys::SSize_T
        streamTo(SeekableInputStream self, OutputStream & soi) -> sys::SSize_T
        """
        return _sio_lite.SeekableInputStream_streamTo(self, *args)

SeekableInputStream_swigregister = _sio_lite.SeekableInputStream_swigregister
SeekableInputStream_swigregister(SeekableInputStream)

class SeekableOutputStream(OutputStream, Seekable):
    """Proxy of C++ io::SeekableOutputStream class"""
    __swig_setmethods__ = {}
    for _s in [OutputStream, Seekable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SeekableOutputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [OutputStream, Seekable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SeekableOutputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_SeekableOutputStream
    __del__ = lambda self: None

    def write(self, b, len):
        """write(SeekableOutputStream self, sys::byte const * b, sys::Size_T len)"""
        return _sio_lite.SeekableOutputStream_write(self, b, len)

SeekableOutputStream_swigregister = _sio_lite.SeekableOutputStream_swigregister
SeekableOutputStream_swigregister(SeekableOutputStream)

class SeekableBidirectionalStream(BidirectionalStream, Seekable):
    """Proxy of C++ io::SeekableBidirectionalStream class"""
    __swig_setmethods__ = {}
    for _s in [BidirectionalStream, Seekable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SeekableBidirectionalStream, name, value)
    __swig_getmethods__ = {}
    for _s in [BidirectionalStream, Seekable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SeekableBidirectionalStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_SeekableBidirectionalStream
    __del__ = lambda self: None

    def read(self, b, len):
        """read(SeekableBidirectionalStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.SeekableBidirectionalStream_read(self, b, len)


    def write(self, b, len):
        """write(SeekableBidirectionalStream self, sys::byte const * b, sys::Size_T len)"""
        return _sio_lite.SeekableBidirectionalStream_write(self, b, len)


    def streamTo(self, *args):
        """
        streamTo(SeekableBidirectionalStream self, OutputStream & soi, sys::SSize_T numBytes) -> sys::SSize_T
        streamTo(SeekableBidirectionalStream self, OutputStream & soi) -> sys::SSize_T
        """
        return _sio_lite.SeekableBidirectionalStream_streamTo(self, *args)

SeekableBidirectionalStream_swigregister = _sio_lite.SeekableBidirectionalStream_swigregister
SeekableBidirectionalStream_swigregister(SeekableBidirectionalStream)

class StringStream(SeekableBidirectionalStream):
    """Proxy of C++ io::StringStream class"""
    __swig_setmethods__ = {}
    for _s in [SeekableBidirectionalStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringStream, name, value)
    __swig_getmethods__ = {}
    for _s in [SeekableBidirectionalStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringStream, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(io::StringStream self) -> StringStream"""
        this = _sio_lite.new_StringStream()
        try:
            self.this.append(this)
        except:
            self.this = this

    def tell(self):
        """tell(StringStream self) -> sys::Off_T"""
        return _sio_lite.StringStream_tell(self)


    def seek(self, offset, whence):
        """seek(StringStream self, sys::Off_T offset, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.StringStream_seek(self, offset, whence)


    def available(self):
        """available(StringStream self) -> sys::Off_T"""
        return _sio_lite.StringStream_available(self)


    def write(self, *args):
        """
        write(StringStream self, sys::byte b)
        write(StringStream self, std::string const & str)
        write(StringStream self, sys::byte const * b, sys::Size_T size)
        """
        return _sio_lite.StringStream_write(self, *args)


    def read(self, b, len):
        """read(StringStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.StringStream_read(self, b, len)


    def stream(self, *args):
        """
        stream(StringStream self) -> std::stringstream const
        stream(StringStream self) -> std::stringstream &
        """
        return _sio_lite.StringStream_stream(self, *args)


    def reset(self):
        """reset(StringStream self)"""
        return _sio_lite.StringStream_reset(self)

    __swig_destroy__ = _sio_lite.delete_StringStream
    __del__ = lambda self: None
StringStream_swigregister = _sio_lite.StringStream_swigregister
StringStream_swigregister(StringStream)

class NullInputStream(InputStream):
    """Proxy of C++ io::NullInputStream class"""
    __swig_setmethods__ = {}
    for _s in [InputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [InputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullInputStream, name)
    __repr__ = _swig_repr

    def __init__(self, size):
        """__init__(io::NullInputStream self, sys::SSize_T size) -> NullInputStream"""
        this = _sio_lite.new_NullInputStream(size)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_NullInputStream
    __del__ = lambda self: None

    def available(self):
        """available(NullInputStream self) -> sys::Off_T"""
        return _sio_lite.NullInputStream_available(self)


    def read(self, b, len):
        """read(NullInputStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.NullInputStream_read(self, b, len)


    def readln(self, cStr, strLenPlusNullByte):
        """readln(NullInputStream self, sys::byte * cStr, sys::Size_T const strLenPlusNullByte) -> sys::SSize_T"""
        return _sio_lite.NullInputStream_readln(self, cStr, strLenPlusNullByte)


    def streamTo(self, *args):
        """
        streamTo(NullInputStream self, OutputStream soi, sys::SSize_T numBytes) -> sys::SSize_T
        streamTo(NullInputStream self, OutputStream soi) -> sys::SSize_T
        """
        return _sio_lite.NullInputStream_streamTo(self, *args)

NullInputStream_swigregister = _sio_lite.NullInputStream_swigregister
NullInputStream_swigregister(NullInputStream)

class NullOutputStream(OutputStream):
    """Proxy of C++ io::NullOutputStream class"""
    __swig_setmethods__ = {}
    for _s in [OutputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullOutputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [OutputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullOutputStream, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(io::NullOutputStream self) -> NullOutputStream"""
        this = _sio_lite.new_NullOutputStream()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_NullOutputStream
    __del__ = lambda self: None

    def writeln(self, arg2):
        """writeln(NullOutputStream self, std::string const & arg2)"""
        return _sio_lite.NullOutputStream_writeln(self, arg2)


    def write(self, *args):
        """
        write(NullOutputStream self, sys::byte arg2)
        write(NullOutputStream self, std::string const & arg2)
        write(NullOutputStream self, sys::byte const * arg2, sys::Size_T arg3)
        """
        return _sio_lite.NullOutputStream_write(self, *args)


    def flush(self):
        """flush(NullOutputStream self)"""
        return _sio_lite.NullOutputStream_flush(self)

NullOutputStream_swigregister = _sio_lite.NullOutputStream_swigregister
NullOutputStream_swigregister(NullOutputStream)

class FileInputStream(SeekableInputStream):
    """Proxy of C++ io::FileInputStreamOS class"""
    __swig_setmethods__ = {}
    for _s in [SeekableInputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [SeekableInputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileInputStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        FileInputStreamOS() -> FileInputStream
        FileInputStreamOS(std::string const & inputFile) -> FileInputStream
        __init__(io::FileInputStreamOS self, sys::File const & inputFile) -> FileInputStream
        """
        this = _sio_lite.new_FileInputStream(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_FileInputStream
    __del__ = lambda self: None

    def available(self):
        """available(FileInputStream self) -> sys::Off_T"""
        return _sio_lite.FileInputStream_available(self)


    def isOpen(self):
        """isOpen(FileInputStream self) -> bool"""
        return _sio_lite.FileInputStream_isOpen(self)


    def create(self, str):
        """create(FileInputStream self, std::string const & str)"""
        return _sio_lite.FileInputStream_create(self, str)


    def seek(self, off, whence):
        """seek(FileInputStream self, sys::Off_T off, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.FileInputStream_seek(self, off, whence)


    def tell(self):
        """tell(FileInputStream self) -> sys::Off_T"""
        return _sio_lite.FileInputStream_tell(self)


    def close(self):
        """close(FileInputStream self)"""
        return _sio_lite.FileInputStream_close(self)


    def read(self, b, len):
        """read(FileInputStream self, sys::byte * b, sys::Size_T len) -> sys::SSize_T"""
        return _sio_lite.FileInputStream_read(self, b, len)

FileInputStream_swigregister = _sio_lite.FileInputStream_swigregister
FileInputStream_swigregister(FileInputStream)

class FileOutputStream(SeekableOutputStream):
    """Proxy of C++ io::FileOutputStreamOS class"""
    __swig_setmethods__ = {}
    for _s in [SeekableOutputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileOutputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [SeekableOutputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileOutputStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        FileOutputStreamOS() -> FileOutputStream
        FileOutputStreamOS(std::string const & outputFile, int creationFlags) -> FileOutputStream
        __init__(io::FileOutputStreamOS self, std::string const & outputFile) -> FileOutputStream
        """
        this = _sio_lite.new_FileOutputStream(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_FileOutputStream
    __del__ = lambda self: None

    def isOpen(self):
        """isOpen(FileOutputStream self) -> bool"""
        return _sio_lite.FileOutputStream_isOpen(self)


    def create(self, *args):
        """
        create(FileOutputStream self, std::string const & str, int creationFlags)
        create(FileOutputStream self, std::string const & str)
        """
        return _sio_lite.FileOutputStream_create(self, *args)


    def close(self):
        """close(FileOutputStream self)"""
        return _sio_lite.FileOutputStream_close(self)


    def flush(self):
        """flush(FileOutputStream self)"""
        return _sio_lite.FileOutputStream_flush(self)


    def seek(self, offset, whence):
        """seek(FileOutputStream self, sys::Off_T offset, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.FileOutputStream_seek(self, offset, whence)


    def tell(self):
        """tell(FileOutputStream self) -> sys::Off_T"""
        return _sio_lite.FileOutputStream_tell(self)


    def write(self, *args):
        """
        write(FileOutputStream self, sys::byte b)
        write(FileOutputStream self, std::string const & str)
        write(FileOutputStream self, sys::byte const * b, sys::Size_T len)
        """
        return _sio_lite.FileOutputStream_write(self, *args)

FileOutputStream_swigregister = _sio_lite.FileOutputStream_swigregister
FileOutputStream_swigregister(FileOutputStream)

class FileHeader(_object):
    """Proxy of C++ sio::lite::FileHeader class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileHeader, name)
    __repr__ = _swig_repr
    UNSIGNED = _sio_lite.FileHeader_UNSIGNED
    SIGNED = _sio_lite.FileHeader_SIGNED
    FLOAT = _sio_lite.FileHeader_FLOAT
    COMPLEX_UNSIGNED = _sio_lite.FileHeader_COMPLEX_UNSIGNED
    COMPLEX_SIGNED = _sio_lite.FileHeader_COMPLEX_SIGNED
    COMPLEX_FLOAT = _sio_lite.FileHeader_COMPLEX_FLOAT
    N_BYTE_UNSIGNED = _sio_lite.FileHeader_N_BYTE_UNSIGNED
    N_BYTE_SIGNED = _sio_lite.FileHeader_N_BYTE_SIGNED

    def __init__(self, *args):
        """
        __init__(sio::lite::FileHeader self, int numLines, int numElements, int elementSize, int elementType, int ver=1) -> FileHeader
        __init__(sio::lite::FileHeader self, int numLines, int numElements, int elementSize, int elementType) -> FileHeader
        __init__(sio::lite::FileHeader self) -> FileHeader
        """
        this = _sio_lite.new_FileHeader(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_FileHeader
    __del__ = lambda self: None

    def getLength(self):
        """getLength(FileHeader self) -> long"""
        return _sio_lite.FileHeader_getLength(self)


    def getNumLines(self):
        """getNumLines(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumLines(self)


    def setNumLines(self, numLines):
        """setNumLines(FileHeader self, int numLines)"""
        return _sio_lite.FileHeader_setNumLines(self, numLines)


    def getNumElements(self):
        """getNumElements(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumElements(self)


    def setNumElements(self, numElements):
        """setNumElements(FileHeader self, int numElements)"""
        return _sio_lite.FileHeader_setNumElements(self, numElements)


    def getElementSize(self):
        """getElementSize(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementSize(self)


    def setElementSize(self, size):
        """setElementSize(FileHeader self, int size)"""
        return _sio_lite.FileHeader_setElementSize(self, size)


    def getElementType(self):
        """getElementType(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementType(self)


    def setElementType(self, type):
        """setElementType(FileHeader self, int type)"""
        return _sio_lite.FileHeader_setElementType(self, type)


    def getElementTypeAsString(self):
        """getElementTypeAsString(FileHeader self) -> std::string"""
        return _sio_lite.FileHeader_getElementTypeAsString(self)


    def getVersion(self):
        """getVersion(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getVersion(self)


    def setVersion(self, newVersion):
        """setVersion(FileHeader self, int newVersion)"""
        return _sio_lite.FileHeader_setVersion(self, newVersion)


    def idsAreNullTerminated(self):
        """idsAreNullTerminated(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_idsAreNullTerminated(self)


    def setNullTerminationFlag(self, flag):
        """setNullTerminationFlag(FileHeader self, bool flag)"""
        return _sio_lite.FileHeader_setNullTerminationFlag(self, flag)


    def isDifferentByteOrdering(self):
        """isDifferentByteOrdering(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_isDifferentByteOrdering(self)


    def setIsDifferentByteOrdering(self, isDifferent):
        """setIsDifferentByteOrdering(FileHeader self, bool isDifferent)"""
        return _sio_lite.FileHeader_setIsDifferentByteOrdering(self, isDifferent)


    def userDataFieldExists(self, key):
        """userDataFieldExists(FileHeader self, std::string key) -> bool"""
        return _sio_lite.FileHeader_userDataFieldExists(self, key)


    def getAllUserDataFields(self, keys):
        """getAllUserDataFields(FileHeader self, std::vector< std::string > & keys)"""
        return _sio_lite.FileHeader_getAllUserDataFields(self, keys)


    def getNumUserDataFields(self):
        """getNumUserDataFields(FileHeader self) -> size_t"""
        return _sio_lite.FileHeader_getNumUserDataFields(self)


    def getUserData(self, key):
        """getUserData(FileHeader self, std::string key) -> std::vector< sys::byte > &"""
        return _sio_lite.FileHeader_getUserData(self, key)


    def getUserDataSection(self, *args):
        """
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary const
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary &
        """
        return _sio_lite.FileHeader_getUserDataSection(self, *args)


    def addUserData(self, *args):
        """
        addUserData(FileHeader self, std::string const & field, std::string const & data)
        addUserData(FileHeader self, std::string const & field, std::vector< sys::byte > const & data)
        addUserData(FileHeader self, std::string const & field, int data)
        """
        return _sio_lite.FileHeader_addUserData(self, *args)


    def to(self, numBands, os):
        """to(FileHeader self, size_t numBands, OutputStream os)"""
        return _sio_lite.FileHeader_to(self, numBands, os)

FileHeader_swigregister = _sio_lite.FileHeader_swigregister
FileHeader_swigregister(FileHeader)

class FileWriter(_object):
    """Proxy of C++ sio::lite::FileWriter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileWriter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(sio::lite::FileWriter self, std::string const & outputFile) -> FileWriter
        __init__(sio::lite::FileWriter self, char const * outputFile) -> FileWriter
        __init__(sio::lite::FileWriter self, OutputStream stream, bool adopt=True) -> FileWriter
        __init__(sio::lite::FileWriter self, OutputStream stream) -> FileWriter
        """
        this = _sio_lite.new_FileWriter(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_FileWriter
    __del__ = lambda self: None

    def write(self, *args):
        """
        write(FileWriter self, FileHeader header, std::vector< io::InputStream * > bandStreams)
        write(FileWriter self, int numLines, int numElements, int elementSize, int elementType, std::vector< io::InputStream * > bandStreams)
        write(FileWriter self, FileHeader header, void const * data, int numBands=1)
        write(FileWriter self, FileHeader header, void const * data)
        write(FileWriter self, int numLines, int numElements, int elementSize, int elementType, void const * data, int numBands=1)
        write(FileWriter self, int numLines, int numElements, int elementSize, int elementType, void const * data)
        write(FileWriter self, FileHeader header, size_t data)
        """
        return _sio_lite.FileWriter_write(self, *args)

FileWriter_swigregister = _sio_lite.FileWriter_swigregister
FileWriter_swigregister(FileWriter)


_sio_lite.AUTO_swigconstant(_sio_lite)
AUTO = _sio_lite.AUTO
class StreamReader(InputStream):
    """Proxy of C++ sio::lite::StreamReader class"""
    __swig_setmethods__ = {}
    for _s in [InputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamReader, name, value)
    __swig_getmethods__ = {}
    for _s in [InputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamReader, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_StreamReader
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(sio::lite::StreamReader self) -> StreamReader
        __init__(sio::lite::StreamReader self, InputStream arg2, bool adopt=False) -> StreamReader
        __init__(sio::lite::StreamReader self, InputStream arg2) -> StreamReader
        """
        this = _sio_lite.new_StreamReader(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setInputStream(self, arg2, adopt=False):
        """
        setInputStream(StreamReader self, InputStream arg2, bool adopt=False)
        setInputStream(StreamReader self, InputStream arg2)
        """
        return _sio_lite.StreamReader_setInputStream(self, arg2, adopt)


    def getInputStream(self):
        """getInputStream(StreamReader self) -> InputStream"""
        return _sio_lite.StreamReader_getInputStream(self)


    def getHeader(self, *args):
        """
        getHeader(StreamReader self) -> FileHeader
        getHeader(StreamReader self) -> FileHeader
        """
        return _sio_lite.StreamReader_getHeader(self, *args)


    def readHeader(self):
        """readHeader(StreamReader self) -> FileHeader"""
        return _sio_lite.StreamReader_readHeader(self)


    def available(self):
        """available(StreamReader self) -> sys::Off_T"""
        return _sio_lite.StreamReader_available(self)


    def read(self, *args):
        """
        read(StreamReader self, sys::byte * b, size_t size) -> sys::SSize_T
        read(StreamReader self, size_t data, size_t size) -> sys::SSize_T
        """
        return _sio_lite.StreamReader_read(self, *args)

StreamReader_swigregister = _sio_lite.StreamReader_swigregister
StreamReader_swigregister(StreamReader)

class FileReader(StreamReader, Seekable):
    """Proxy of C++ sio::lite::FileReader class"""
    __swig_setmethods__ = {}
    for _s in [StreamReader, Seekable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileReader, name, value)
    __swig_getmethods__ = {}
    for _s in [StreamReader, Seekable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileReader, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_FileReader
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(sio::lite::FileReader self) -> FileReader
        __init__(sio::lite::FileReader self, std::string file) -> FileReader
        __init__(sio::lite::FileReader self, io::FileInputStream * arg2, bool adopt=False) -> FileReader
        __init__(sio::lite::FileReader self, io::FileInputStream * arg2) -> FileReader
        """
        this = _sio_lite.new_FileReader(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def seek(self, offset, whence):
        """seek(FileReader self, sys::Off_T offset, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.FileReader_seek(self, offset, whence)


    def tell(self):
        """tell(FileReader self) -> sys::Off_T"""
        return _sio_lite.FileReader_tell(self)


    def killStream(self):
        """killStream(FileReader self)"""
        return _sio_lite.FileReader_killStream(self)

FileReader_swigregister = _sio_lite.FileReader_swigregister
FileReader_swigregister(FileReader)

def write(numpyArray, outputPathname, elementType = None):
    # Make sure this array is sized properly
    if len(numpyArray.shape) != 2:
        raise Exception("Only 2 dimensional images are supported")

    if elementType == None:
        signedType = ['int8', 'int16', 'int32', 'int64']
        unsignedType = ['uint8', 'uint16', 'uint32', 'uint64']
        floatType = ['float32', 'float64']
        complexFloatType = ['complex64', 'complex128']
        
        if numpyArray.dtype in signedType:
            elementType = FileHeader.SIGNED
        elif numpyArray.dtype in unsignedType:
            elementType = FileHeader.UNSIGNED
        elif numpyArray.dtype in floatType:
            elementType = FileHeader.FLOAT
        elif numpyArray.dtype in complexFloatType:
            elmenetType = FileHeader.COMPLEX_FLOAT
        else:
            raise Exception("Unknown element type: " + str(numpyArray.dtype))
            
    header = FileHeader(numpyArray.shape[0], numpyArray.shape[1], numpyArray.strides[1], elementType);
    
    pointer, ro = numpyArray.__array_interface__['data']
    
    if pointer == 0 or pointer == None:
        raise Exception("Attempting to write a NULL image")
    
    writer = FileWriter(outputPathname)
    writer.write(header, pointer)

import numpy

def read(inputPathname):
    reader = FileReader(inputPathname)
    header = reader.getHeader()
    
    elementType = header.getElementType()
    elementSize = header.getElementSize()
    
    if elementType == FileHeader.UNSIGNED:
        dtype = 'uint'
    elif elementType == FileHeader.SIGNED:
        dtype = 'int'
    elif elementType == FileHeader.FLOAT:
        dtype = 'float'
    elif elementType == FileHeader.COMPLEX_FLOAT:
        dtype = 'complex'
    else:
        raise Exception("Unknown element type: " + str(elementType))
        
    dtype += str(elementSize * 8)

    numpyArray = numpy.empty(shape = (header.getNumLines(), header.getNumElements()), dtype = dtype)
    pointer, ro = numpyArray.__array_interface__['data']
    reader.read(pointer, numpyArray.shape[0] * numpyArray.shape[1] * elementSize)
    return numpyArray;

# This file is compatible with both classic and new-style classes.


